<section>
  <title>How to make a good dependency injection container? Software
         good practices</title>
  <para>
    This article, which is going to talk about many subjects, is based
    on a personal experience and investigations I had during the
    realisation of a piece of software, for my personal use. No more
    suspence, this software is a dependency container, used in a web
    framework project, as a main piece.
  </para>
  <section>
    <title>Aims of this article</title>
    <para>
      In this article, I'll talk to you about dependency injection, and
      especially, how to build a succesfully and easy extendable
      dependency injection container. This article will be divided into 5
      parts. It's important to understand each part, in is totality.
    </para>
    <para>
      I will talk about software architecture in general, but, also about
      good practices, and it can change the way you code your
      applications. In fact, if you don't already use inversion of
      control pattern, it <emphasis role="strong">will</emphasis> do
      change the way you code. Maybe am I a little optimistic ? Let's see
      !
    </para>
  </section>
  <section>
    <title>How do we actually manage objects</title>
    <para>
      First of all, we have to explain, briefly, what is inversion of
      control, in order to completely understand all things we are gonna
      do. When you are making sofware, in an Object Oriented way, you
      create classes that will interact.
    </para>
    <para>
      A common practice is to call some classes from others. You'll
      understand quickly what is inversion of control.
    </para>
    <para>
      Let's imagine we have a <literal>Car</literal> class, wich is
      dependent on a tire <literal>MichelinTire</literal> object. Here is
      an exemple of dependent code:
    </para>
    <screen>
class RedCar {
    protected $_tire = null;

    public function __construct(){
        $this-&gt;_tire = new MichelinTire();
    }
}
</screen>
    <para>
      When building the Car, constructor build for us the tire, and
      return us a great car, with the Tires already build in.
    </para>
    <section>
      <title>This includes dependencies !</title>
      <para>
        The problem that appears is simple: our <literal>Car</literal> is
        now dependent on <literal>MichelinTire</literal>s. If, for
        instance, we want to put on another brand of
        <literal>Tire</literal>s, we can't !
      </para>
    </section>
  </section>
  <section>
    <title>Inversion of control</title>
    <section>
      <title>Principle</title>
      <para>
        <inlinemediaobject>
          <imageobject>
            <imagedata fileref="articles/dependency-injection/holywood-principle.png" />
          </imageobject>
        </inlinemediaobject>
      </para>
      <para>
        The solution to this problem is simple, we need to remove the
        dependency between our two objects.
      </para>
      <screen>
class RedCar {
    protected $_tire = null;

    public function __construct(Tire $tire){
        $this-&gt;_tire = $tire;
    }
}   
</screen>
      <para>
        As you can see, the <literal>Tire</literal> is given in the
        constructor of our <literal>Car</literal>, and no more builded into
        the constructor. You can remember this as the
        <emphasis role="strong">Hollywood principle</emphasis> :
        <emphasis>don't call me, I'll call you</emphasis>, or in other
        worlds, dont use the <literal>new</literal> operator to create your
        objects inside our classes, but passes all your objects via
        constructors, or via setters.
      </para>
      <para>
        Here is an exemple using setters:
      </para>
      <screen>
class RedCar {
    protected $_tire = null;

    public function setTire(Tire $tire){
        $this-&gt;_tire = $tire;
    }
}   
</screen>
      <para>
        Maybe have you noticed that the <literal>setTire</literal> method
        is waiting for a <literal>Tire</literal>, and not for the special
        <literal>MichelinTire</literal>. You're right, and it allows us to
        be dependent, not on a special implementation of a Tire, but on
        <emphasis role="strong">all</emphasis> possible implementations of
        <literal>Tire</literal>s. In fact, <literal>Tire</literal> is the
        <emphasis>interface</emphasis> of all our Tire.
      </para>
      <para>
        That's all for the inversion of control principle: it just invert
        the flow of control of your applications by delegating at a higher
        level the creation of objects.
      </para>
    </section>
    <section>
      <title>Dependency injection</title>
      <para>
        Ok, now that the concept of inversion of control is clear in your
        head, it make more sense to explain what is the dependency
        injection.
      </para>
      <para>
        In the precendent section, the <literal>Car</literal> was
        <emphasis>dependent</emphasis> on the <literal>Tire</literal>. By
        inverting the flow of control, our class is now more testable
        (using mocks objects is now really simple, as setting a parameter,
        using setter), but we have to create our <literal>Tire</literal>,
        and inject it into our <literal>RedCar</literal> object.
      </para>
      <para>
        To <emphasis>inject</emphasis> is the main word. Dependency
        injection is just that: call our setters or constructors. So, let's
        go !
      </para>
      <screen>
$myTire = new MichelinTire();
$myCar = new RedCar();
$myCar-&gt;setTire($myTire);
</screen>
    </section>
    <section>
      <title>A dependency injection container ?</title>
      <para>
        In our case, it's really really simple, because we have just two
        classes, and one dependency. In important projects, with tons of
        classes and tons of dependencies, managing object lifecycles can
        become a hard work ! The dependency injection task can be
        automatised, and this is the aim of a dependency injector.
      </para>
      <para>
        Why &quot;container&quot; ? Because the principle of automatizing
        theses creation and injection task is done thanks to a container,
        wich contains all relation schema.
      </para>
      <para>
        Always with the same exemple, the dependency injection container
        will do the injection, on his own.
      </para>
      <para>
        Here is some important concepts that I've used when realising this
        software.
      </para>
    </section>
  </section>
  <section>
    <title>The concepts</title>
    <section>
      <title>The Schema representation</title>
      <para>
        Schema represents the way object and classes are linked together.
        It's this schema the most important thing in the overall concepts.
      </para>
      <para>
        The Schema contains all informations about methods we have to call
        to inject our objects, argument types, and all other information
        that can be useful to know at the injection time.
      </para>
      <para>
        In our exemple, the schema will contain information on wich
        <literal>Tire</literal> the <literal>Car</literal> is dependent,
        and wich is the way to provide the good <literal>Tire</literal> to
        the <literal>Car</literal> (let's say by setter).
      </para>
      <section>
        <title>Services</title>
        <para>
        </para>
      </section>
      <section>
        <title>Methods</title>
        <para>
        </para>
      </section>
      <section>
        <title>Arguments</title>
        <para>
        </para>
      </section>
    </section>
    <section>
      <title>Construction strategies</title>
      <para>
        I've choosen to separate completely
      </para>
    </section>
    <section>
      <title>Builders</title>
      <para>
        Builders, are classes that are capable of building a schema object
        from other forms of schema, like XML, or YAML, or, why not, plain
        text, that are more human comprehensive.
      </para>
    </section>
    <section>
      <title>Dumpers</title>
      <para>
      </para>
    </section>
  </section>
  <section>
    <title>Implementation</title>
    <section>
      <title>Namespaces / PHP 5.3</title>
      <para>
      </para>
    </section>
    <section>
      <title>Test driven developement</title>
      <para>
      </para>
    </section>
    <section>
      <title>Writing classes</title>
      <para>
      </para>
    </section>
  </section>
  <section>
    <title>One step further: how to extends the Container ?</title>
    <para>
      Now that we know what we have to make, let's reflect on how this
      can be an useful tool in our future developements. The Dependency
      Injection is, when we're thinking about, just like a big [abstract
      factory][]. It build objects and call some methods
    </para>
  </section>
</section>

